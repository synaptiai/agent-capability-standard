# Workflow Catalog (36-capability model)
# Maps to capability_ontology.yaml
#
# Domain-specific workflows are in separate files:
#   - schemas/workflows/manufacturing_workflows.yaml
#   - schemas/workflows/personal_assistant_workflows.yaml
#   - schemas/workflows/data_analysis_workflows.yaml
#   - schemas/workflows/healthcare_workflows.yaml
#
# See docs/domains/ for domain documentation and customization guides.
#
# Capability Mapping (old → new):
#   inspect → observe
#   map-relationships → attribute
#   model-schema → constrain
#   act-plan → execute
#   identity-resolution → (composition: detect + classify + integrate)
#   world-state → state
#   state-transition → transition
#   causal-model → attribute
#   uncertainty-model → measure (with domain: uncertainty)
#   provenance → audit
#   grounding → ground
#   simulation → simulate
#   summarize → explain
#   discover-relationship → discover
#   compare-plans → compare
#   prioritize → compare (with domain: priority)
#   generate-plan → generate (with domain: plan)
#   diff-world-state → compare (with domain: state_diff)
#   detect-anomaly → detect (with domain: anomaly)
#   estimate-risk → measure (with domain: risk)
#   forecast-risk → predict (with domain: risk)
#   invoke-workflow → invoke
#
# New workflow patterns (Issue #9):
#   monitor-and-replan: Detect world changes and trigger replanning when needed
#   clarify-intent: Resolve ambiguous user requests through clarification

monitor_and_replan:
  goal: Detect world changes that invalidate the current plan and trigger replanning when needed.
  risk: medium
  description: |
    This workflow pattern continuously monitors world state against plan assumptions
    and triggers replanning when significant divergence is detected. It's designed
    to be invoked periodically during plan execution or when external events suggest
    the world may have changed.
  success:
  - Plan assumptions validated OR violations detected
  - If violations detected, revised plan generated
  - Audit trail of assumption checks maintained
  steps:
  - capability: observe
    purpose: Capture current world state for comparison.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: current_state_out
    failure_modes:
    - condition: Unable to observe relevant state
      action: request_more_context
      recovery: Request specific state aspects to monitor.
  - capability: state
    purpose: Create structured state representation.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: world_state_out
    input_bindings:
      scope: ${plan.scope}
    failure_modes: []
  - capability: compare
    purpose: Compare current state against plan assumptions.
    domain: assumption_validation
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: comparison_out
    input_bindings:
      options:
      - ${world_state_out}
      - ${plan.assumed_state}
      criteria:
      - assumption_validity
      - state_divergence
    failure_modes: []
  - capability: detect
    purpose: Detect assumption violations that affect plan validity.
    domain: plan-invalidation
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: violations_out
    input_bindings:
      data: ${comparison_out}
      pattern: assumption_violation
    gates:
    - when: ${comparison_out.confidence} > 0.9
      action: stop
      message: No significant divergence detected, plan remains valid.
    failure_modes: []
  - capability: critique
    purpose: Assess impact of violations on current plan.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: critique_out
    input_bindings:
      target: ${plan}
      criteria:
      - step_validity
      - goal_achievability
      - resource_availability
    failure_modes: []
  - capability: plan
    purpose: Generate revised plan incorporating new constraints.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: revised_plan_out
    input_bindings:
      goal: ${plan.goal}
      constraints:
      - ${violations_out.matches: array<object>}
      - ${critique_out.suggestions: array<string>}
    gates:
    - when: ${critique_out.severity} == "minor"
      action: skip
      message: Minor violation, continue with current plan.
    failure_modes:
    - condition: Unable to find viable plan
      action: stop
      recovery: Escalate to human with violation details.
  - capability: audit
    purpose: Record assumption check and any replanning decision.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: assumption_check
        original_plan: ${plan.id}
        violations: ${violations_out.detected}
        revised_plan: "${revised_plan_out.steps: array<object>}"
    failure_modes: []
  inputs:
    plan:
      type: object
      required: true
      properties:
        id: {type: string}
        goal: {type: string}
        scope: {type: string}
        assumed_state: {type: object}

clarify_intent:
  goal: Resolve ambiguous user requests through targeted clarification questions.
  risk: low
  description: |
    This workflow analyzes a user request for ambiguity, generates clarifying
    questions when needed, and integrates the clarification to produce a
    well-specified request. It's designed to be invoked at the start of
    any workflow when the initial request may be underspecified.
  success:
  - Request analyzed for ambiguity
  - Clarifying questions generated if needed
  - Clarification integrated into resolved request
  steps:
  - capability: critique
    purpose: Analyze request for ambiguity and missing parameters.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: ambiguity_analysis_out
    input_bindings:
      target: ${user_request}
      criteria:
      - parameter_completeness
      - interpretation_uniqueness
      - constraint_clarity
    failure_modes: []
  - capability: inquire
    purpose: Generate clarifying questions for ambiguous elements.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: clarification_request_out
    input_bindings:
      ambiguous_input: ${user_request}
      context: ${conversation_context}
      max_questions: 3
    gates:
    - when: ${ambiguity_analysis_out.confidence} > 0.85
      action: skip
      message: Request is sufficiently clear, no clarification needed.
    failure_modes: []
  - capability: send
    purpose: Present clarifying questions to user.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: sent_questions_out
    input_bindings:
      destination: user
      payload: ${clarification_request_out.questions}
    gates:
    - when: ${clarification_request_out.confidence} < 0.5
      action: skip
      message: No clarifying questions needed.
    failure_modes: []
  - capability: receive
    purpose: Accept user's clarification response.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry: null
    store_as: clarification_response_out
    input_bindings:
      channel: user
      filter:
        type: clarification_response
    gates:
    - when: ${sent_questions_out} == null
      action: skip
      message: No questions were sent, nothing to receive.
    failure_modes:
    - condition: Timeout waiting for response
      action: stop
      recovery: Proceed with best interpretation or escalate.
  - capability: integrate
    purpose: Merge clarification with original request.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: resolved_request_out
    input_bindings:
      sources:
      - ${user_request}
      - ${clarification_response_out.data}
      strategy: parameter_merge
      conflict_resolution: prefer_clarification
    failure_modes: []
  - capability: audit
    purpose: Record clarification interaction for provenance.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: intent_clarification
        original_request: ${user_request}
        questions_asked: ${clarification_request_out.questions}
        clarification_received: ${clarification_response_out.data}
        resolved_request: ${resolved_request_out}
    failure_modes: []
  inputs:
    user_request:
      type: string
      required: true
      description: The potentially ambiguous user request
    conversation_context:
      type: object
      required: false
      description: Previous conversation context for better question generation

debug_code_change:
  goal: Safely diagnose and fix a bug/regression in a codebase.
  risk: medium
  steps:
  - capability: observe
    purpose: Observe failing behavior, logs, and relevant code paths.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: observe_out
    failure_modes:
    - condition: No relevant signals found
      action: request_more_context
      recovery: Ask for reproduction steps or additional artifacts.
  - capability: search
    purpose: Find related code, configs, and error patterns.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: search_out
    failure_modes: []
  - capability: attribute
    purpose: Build dependency graph and identify causal relationships around failing component.
    domain: dependencies
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: attribute_out
    failure_modes: []
  - capability: constrain
    purpose: Define invariants/spec expectations for the component.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: constrain_out
    failure_modes: []
  - capability: critique
    purpose: List likely failure modes + edge cases.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: critique_out
    failure_modes: []
  - capability: plan
    purpose: Produce minimal fix plan with checkpoints.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: plan_out
    failure_modes: []
  - capability: checkpoint
    purpose: Create checkpoint before mutation.
    risk: medium
    mutation: true
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: checkpoint_out
    failure_modes: []
  - capability: execute
    purpose: Apply fix, run tests, and produce diff summary.
    risk: high
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: 5m
    retry: null
    store_as: execute_out
    failure_modes:
    - condition: Unexpected side effects
      action: pause_and_checkpoint
      recovery: Checkpoint and require human approval.
  - capability: verify
    purpose: Run targeted verification and return PASS/FAIL.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry:
      max: 3
      backoff: exponential
    store_as: verify_out
    failure_modes:
    - condition: Verdict == FAIL
      action: rollback
      recovery: Rollback, then return to critique/plan with new evidence.
  - capability: audit
    purpose: Record what changed and why.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
  - capability: rollback
    purpose: If verify FAIL, revert safely.
    risk: medium
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: null
    retry: null
    store_as: rollback_out
    failure_modes: []
  success:
  - Bug fixed or root cause isolated
  - Verification PASS
  - Audit trail produced
  risk_propagation:
    strategy: max_step_risk
    computed_risk: high
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

world_model_build:
  goal: Construct a structured world model for a domain (real or digital) with dynamics and uncertainty.
  risk: low
  steps:
  - capability: retrieve
    purpose: Collect authoritative domain sources and constraints.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: retrieve_out
    failure_modes: []
  - capability: observe
    purpose: Observe current system/world artifacts (docs, logs, sensors).
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: observe_out
    failure_modes:
    - condition: No relevant signals found
      action: request_more_context
      recovery: Ask for reproduction steps or additional artifacts.
  - capability: detect
    purpose: Detect entities across sources.
    domain: entity
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_out
    failure_modes: []
  - capability: classify
    purpose: Classify detected entities and resolve types.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: classify_out
    failure_modes: []
  - capability: integrate
    purpose: Merge entity data and resolve identity across sources.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: integrate_out
    failure_modes: []
  - capability: state
    purpose: Define state variables and current estimates.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: state_out
    failure_modes: []
  - capability: transition
    purpose: 'Define dynamics: transitions, triggers, guards.'
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: transition_out
    failure_modes: []
  - capability: attribute
    purpose: Define causal assumptions and intervention effects.
    domain: causation
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: attribute_out
    failure_modes: []
  - capability: measure
    purpose: Attach uncertainty types and confidence.
    domain: uncertainty
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: measure_out
    failure_modes: []
  - capability: audit
    purpose: Establish lineage for claims and transformations.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
  - capability: ground
    purpose: Anchor each model element to evidence references.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: ground_out
    failure_modes: []
  - capability: simulate
    purpose: Run scenarios to stress-test model and identify fragility.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: simulate_out
    failure_modes: []
  - capability: explain
    purpose: Produce a decision-ready world model brief.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: explain_out
    failure_modes: []
  success:
  - Model is structured (YAML/JSON)
  - Every claim is grounded
  - Uncertainty explicitly represented
  - Scenario results provided
  risk_propagation:
    strategy: max_step_risk
    computed_risk: low
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

capability_gap_analysis:
  goal: Assess a project/system to identify missing capabilities and propose new skills.
  risk: low
  steps:
  - capability: observe
    purpose: Read project docs and current skill coverage.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: observe_out
    failure_modes:
    - condition: No relevant signals found
      action: request_more_context
      recovery: Ask for reproduction steps or additional artifacts.
  - capability: attribute
    purpose: Map existing workflows vs capabilities.
    domain: dependencies
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: attribute_out
    failure_modes: []
  - capability: discover
    purpose: Find hidden dependencies or unmodeled interactions.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: discover_out
    failure_modes: []
  - capability: compare
    purpose: Compare alternative skill architectures.
    domain: architecture
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: compare_architecture_out
    failure_modes: []
  - capability: compare
    purpose: Rank missing capabilities by leverage and risk reduction.
    domain: priority
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: compare_priority_out
    failure_modes: []
  - capability: generate
    purpose: Generate an implementation plan for new skills.
    domain: plan
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: generate_out
    failure_modes: []
  - capability: audit
    purpose: Record rationale + decision lineage.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
  success:
  - Missing capability list
  - Prioritized backlog
  - Proposed skill specs
  risk_propagation:
    strategy: max_step_risk
    computed_risk: medium
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

digital_twin_sync_loop:
  goal: Synchronize digital twin state with incoming signals, detect drift, decide and execute safe actions, and record provenance.
  risk: high
  success:
  - Twin snapshot updated and grounded
  - Drift assessed with risk score
  - Any actions are approved/checkpointed/verified
  - Audit trail produced
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output stored as `store_as`; later steps may reference it.
  steps:
  - capability: receive
    purpose: Ingest new signals/events from sources (logs/APIs/messages).
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry:
      max: 3
      backoff: exponential
    store_as: receive_out
    failure_modes:
    - condition: No messages/events available
      action: stop
      recovery: Wait for signals or confirm source configuration.
    input_bindings: {}
    gates: []
  - capability: search
    purpose: 'Parallel enrichment: search for existing twin snapshot or relevant context while ingesting events.'
    parallel_group: context_gathering
    join: all_complete
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: search_out
    input_bindings:
      target: ${receive_out.source}
    failure_modes: []
  - capability: transform
    purpose: Normalize raw signals into canonical events compatible with state.observations.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: transform_out
    failure_modes: []
    input_bindings:
      source: '${receive_out.data}'
      target_schema: canonical_event
    gates: []
    mapping_ref: schemas/transforms/transform_mapping_rawlog_to_observation.yaml
    output_conforms_to: schemas/event_schema.yaml#/event
  - capability: integrate
    purpose: Merge canonical events with existing twin snapshot; resolve conflicts via strategy.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: integrate_out
    failure_modes:
    - condition: Conflicts exceed threshold
      action: request_more_context
      recovery: Ask for resolution strategy or authoritative source preference.
    input_bindings:
      sources:
      - '${transform_out.output}'
      - '${previous_world_state}'
      resolution_strategy: prefer_authoritative_sources
    gates: []
    resolution_strategy: prefer_authoritative_sources
    conflict_resolution_strategies:
    - prefer_authoritative_sources
    - prefer_recent
    - prefer_high_confidence
    - merge_with_uncertainty
    - escalate_to_human
  - capability: detect
    purpose: Detect entities in integrated data.
    domain: entity
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_entity_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: classify
    purpose: Classify and resolve entity identities.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: classify_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: state
    purpose: Produce updated canonical world-state snapshot with uncertainty + provenance.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: state_out
    failure_modes: []
    input_bindings:
      observations: '${integrate_out.merged.observations: array<object>}'
      domain: ${integrate_out.merged.meta.world_id}
    gates: []
    output_conforms_to: schemas/world_state_schema.yaml#/world_state
  - capability: compare
    purpose: Compute diff between previous snapshot and updated snapshot.
    domain: state_diff
    store_as: compare_state_out
    input_bindings:
      state_a: '${previous_world_state: object}'
      state_b: '${state_out: object}'
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    failure_modes: []
  - capability: transition
    purpose: Apply transition rules triggered by new observations; compute next states.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: transition_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: detect
    purpose: Detect drift/anomalies between expected and observed state.
    domain: anomaly
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_anomaly_out
    failure_modes: []
    input_bindings:
      context: ${state_out}
    gates: []
  - capability: measure
    purpose: Estimate risk impact/probability from drift and transitions.
    domain: risk
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: measure_risk_out
    failure_modes: []
    input_bindings:
      context: ${detect_anomaly_out}
    gates: []
  - capability: predict
    purpose: Forecast near-term risk trajectory and triggers.
    domain: risk
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: predict_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: plan
    purpose: Plan safe action(s) to reduce risk, with verification criteria and rollback plan.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: plan_out
    failure_modes: []
    input_bindings:
      context: ${predict_out}
    gates: []
  - capability: constrain
    purpose: Enforce policy and least privilege for planned actions.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: constrain_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: checkpoint
    purpose: Create checkpoint marker before any mutation/side-effect step.
    risk: medium
    mutation: true
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: checkpoint_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: mutate
    purpose: Execute mutations from action plan (if approved).
    risk: high
    mutation: true
    requires_checkpoint: true
    requires_approval: true
    timeout: 5m
    retry: null
    store_as: mutate_out
    failure_modes:
    - condition: Unexpected side effects
      action: pause_and_checkpoint
      recovery: Require human approval to proceed.
    input_bindings: {}
    gates:
    - when: ${checkpoint_out.checkpoint_id} == null
      action: stop
      message: No checkpoint created. Do not mutate.
    condition: ${constrain_out.compliant} == true
    skip_if_false: true
  - capability: execute
    purpose: Run verification tests and commands.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry: null
    store_as: execute_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: verify
    purpose: 'Verify outcome: PASS/FAIL with evidence.'
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry:
      max: 3
      backoff: exponential
    store_as: verify_out
    failure_modes:
    - condition: Verdict == FAIL
      action: rollback
      recovery:
        goto_step: plan
        inject_context:
          failure_evidence: ${verify_out.failures}
        max_loops: 3
    input_bindings: {}
    gates:
    - when: ${verify_out.passed} == false
      action: rollback
      message: Verification failed. Rolling back.
  - capability: audit
    purpose: Record provenance, tool usage, diffs, and decision rationale.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: rollback
    purpose: If verify FAIL or side effects detected, rollback to checkpoint.
    risk: medium
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: null
    retry: null
    store_as: rollback_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: explain
    purpose: 'Produce decision-ready sync report: drift, actions, verification, next steps.'
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: explain_out
    failure_modes: []
    input_bindings: {}
    gates: []
  workflow_extensions:
    supports_input_bindings: true
    supports_conditions: true
    supports_parallel_groups: true
    supports_recovery_loops: true
    supports_gates: true
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

digital_twin_bootstrap:
  goal: Initialize a digital twin from scratch then run a first sync loop.
  risk: high
  success:
  - World model built
  - First sync completed
  - Audit produced
  steps:
  - capability: invoke
    purpose: Build initial world model baseline
    workflow_id: world_model_build
    store_as: world_model_out
    condition: ${world_state_out} == null
    skip_if_false: true
    input_bindings:
      inputs:
        domain: ${user_input.domain}
        constraints: ${user_input.constraints}
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    failure_modes: []
  - capability: invoke
    purpose: Run initial sync loop using baseline
    workflow_id: digital_twin_sync_loop
    store_as: sync_out
    input_bindings:
      inputs:
        # Note: result contains nested workflow output where state_out was stored
        world_state: ${world_model_out.result}
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    failure_modes: []
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

# OASF-inspired workflow patterns (Issue #23)
# These patterns are derived from OASF skill categories mapped to our
# 36-capability model. See docs/research/analysis/OASF_comparison.md Section 5.

rag_pipeline:
  goal: Retrieve relevant information and generate a grounded, evidence-cited response.
  risk: low
  description: |
    Retrieval-Augmented Generation pipeline inspired by OASF Category 6 (RAG).
    Searches for relevant documents, extracts pertinent passages, anchors the
    response to retrieved evidence, generates a response, and cites sources.
    This pattern ensures generated content is grounded in retrieved facts rather
    than relying solely on parametric knowledge.
  success:
  - Relevant documents found and retrieved
  - Response grounded in retrieved evidence
  - Sources cited with provenance
  steps:
  - capability: search
    purpose: Find relevant documents matching the query.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry:
      max: 2
      backoff: exponential
    store_as: search_out
    input_bindings:
      query: ${user_query}
    failure_modes:
    - condition: No relevant documents found
      action: request_more_context
      recovery: Broaden search terms or ask user for additional context.
  - capability: retrieve
    purpose: Fetch full content of relevant documents.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry:
      max: 2
      backoff: exponential
    store_as: retrieve_out
    input_bindings:
      target: ${user_query}
      references: "${search_out.results: array<object>}"
    failure_modes:
    - condition: Document retrieval fails
      action: request_more_context
      recovery: Try alternative sources or report partial results.
  - capability: detect
    purpose: Extract relevant passages from retrieved documents.
    domain: relevance
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_out
    input_bindings:
      data: "${retrieve_out.data: object}"
      pattern: ${user_query}
    failure_modes: []
  - capability: ground
    purpose: Anchor response to retrieved evidence with provenance.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: ground_out
    input_bindings:
      claim: ${user_query}
      sources: "${search_out.results: array<object>}"
    failure_modes: []
  - capability: generate
    purpose: Produce response synthesized from grounded evidence.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: generate_out
    input_bindings:
      specification: "${ground_out.evidence: array<object>}"
    failure_modes:
    - condition: Insufficient evidence for coherent response
      action: stop
      recovery: Report that available evidence is insufficient and cite what was found.
  - capability: explain
    purpose: Cite sources and provide reasoning chain for the response.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: explain_out
    input_bindings:
      conclusion: "${generate_out.content: object}"
    failure_modes: []
  - capability: audit
    purpose: Record retrieval provenance and generation lineage.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: rag_pipeline
        query: ${user_query}
        grounded: ${ground_out.grounded}
        response: "${generate_out.content: object}"
    failure_modes: []
  risk_propagation:
    strategy: max_step_risk
    computed_risk: low
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    user_query:
      type: string
      required: true
      description: The user query to answer using retrieved information

security_assessment:
  goal: Identify and assess security vulnerabilities with risk scoring and mitigation recommendations.
  # Risk: low — all steps are read-only analysis (search, detect, measure,
  # attribute, critique, generate, audit); no mutations or external tool invocations.
  risk: low
  description: |
    Security assessment workflow inspired by OASF Category 8 (Security & Privacy).
    Scans for known vulnerability patterns, detects potential security issues,
    assesses severity, identifies root causes, evaluates mitigation options,
    generates a security report, and records assessment findings for audit.
  success:
  - Vulnerability scan completed
  - Severity assessed with risk scores
  - Root causes identified
  - Mitigation recommendations produced
  - Assessment findings recorded
  steps:
  - capability: search
    purpose: Scan for known vulnerability patterns and CVEs.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry:
      max: 2
      backoff: exponential
    store_as: search_out
    input_bindings:
      query: ${assessment_target}
    failure_modes:
    - condition: Unable to access vulnerability databases
      action: request_more_context
      recovery: Fall back to pattern-based detection without CVE lookup.
  - capability: detect
    purpose: Find potential security issues in the target.
    domain: vulnerability
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_out
    input_bindings:
      data: "${search_out.results: array<object>}"
      pattern: vulnerability
    failure_modes:
    - condition: No vulnerabilities detected
      action: stop
      recovery: Report clean assessment with confidence level.
  - capability: measure
    purpose: Assess severity and risk level of detected vulnerabilities.
    domain: severity
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: measure_out
    input_bindings:
      target: "${detect_out.matches: array<object>}"
      metric: severity
    failure_modes: []
  - capability: attribute
    purpose: Identify root causes and attack vectors for vulnerabilities.
    domain: causation
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: attribute_out
    input_bindings:
      effect: "${detect_out.matches: array<object>}"
      context: "${search_out: object}"
    failure_modes: []
  - capability: critique
    purpose: Evaluate mitigation options and their trade-offs.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: critique_out
    input_bindings:
      target: "${attribute_out.causes: array<object>}"
      criteria:
      - mitigation_effectiveness
      - implementation_cost
      - operational_impact
    failure_modes: []
  - capability: generate
    purpose: Produce comprehensive security assessment report.
    domain: report
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: generate_out
    input_bindings:
      specification: "${critique_out.suggestions: array<object>}"
    failure_modes: []
  - capability: audit
    purpose: Record assessment findings and recommendations for compliance.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: security_assessment
        target: ${assessment_target}
        severity: ${measure_out.value}
        report: "${generate_out.content: object}"
    failure_modes: []
  risk_propagation:
    strategy: max_step_risk
    computed_risk: low
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    assessment_target:
      type: object
      required: true
      description: The system, codebase, or artifact to assess for security vulnerabilities
      properties:
        target_type:
          type: string
        scope:
          type: string
        constraints:
          type: object

multi_agent_orchestration:
  goal: Coordinate multiple agents to execute a complex task through decomposition, delegation, and result integration.
  risk: medium
  description: |
    Multi-agent orchestration workflow inspired by OASF Category 10 (Agent Orchestration).
    Decomposes a complex task into subtasks, creates an execution plan with
    dependencies, delegates subtasks to appropriate agents, coordinates shared
    state, validates results, merges outputs, and records orchestration decisions.
  success:
  - Task decomposed into manageable subtasks
  - Subtasks delegated to appropriate agents
  - Shared state coordinated across agents
  - Results validated and integrated
  - Orchestration decisions audited
  steps:
  - capability: decompose
    purpose: Break complex task into independent subtasks.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: decompose_out
    input_bindings:
      problem: ${task.goal}
    failure_modes:
    - condition: Task cannot be meaningfully decomposed
      action: stop
      recovery: Execute task as a single unit without delegation.
  - capability: plan
    purpose: Create execution plan with subtask dependencies and ordering.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: plan_out
    input_bindings:
      goal: ${task.goal}
      constraints: "${decompose_out.structure: object}"
    failure_modes: []
  - capability: delegate
    purpose: Assign subtasks to appropriate agents based on capabilities.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: true
    timeout: null
    retry: null
    store_as: delegate_out
    input_bindings:
      task: "${plan_out.dependencies: object}"
    failure_modes:
    - condition: No suitable agent available for subtask
      action: request_more_context
      recovery: Queue subtask or request manual agent assignment.
  - capability: synchronize
    purpose: Coordinate shared state across delegated agents.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry:
      max: 3
      backoff: exponential
    store_as: synchronize_out
    input_bindings:
      agents: "${task.agent_pool: array<string>}"
      state: "${delegate_out: object}"
    failure_modes:
    - condition: State synchronization timeout
      action: pause_and_checkpoint
      recovery: Checkpoint current state and retry synchronization.
  - capability: verify
    purpose: Validate subtask results meet acceptance criteria.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry:
      max: 2
      backoff: exponential
    store_as: verify_out
    input_bindings:
      target: "${delegate_out: object}"
      conditions:
      - subtask_completion
      - result_validity
    failure_modes:
    - condition: Subtask result fails validation
      action: request_more_context
      recovery: Return subtask to assigned agent with failure details.
  - capability: integrate
    purpose: Merge results from multiple agents into unified output.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: integrate_out
    input_bindings:
      sources:
      - "${delegate_out: object}"
      - "${synchronize_out.agreed_state: object}"
      strategy: merge_by_subtask
    failure_modes:
    - condition: Conflicting results from agents
      action: request_more_context
      recovery: Escalate conflicts for manual resolution.
  - capability: audit
    purpose: Record orchestration decisions, delegations, and results.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: multi_agent_orchestration
        task: ${task.goal}
        plan: "${plan_out.steps: array<object>}"
        delegation: ${delegate_out.accepted}
        results: "${integrate_out.merged: object}"
    failure_modes: []
  risk_propagation:
    strategy: max_step_risk
    computed_risk: medium
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    task:
      type: object
      required: true
      description: The complex task to orchestrate across multiple agents
      properties:
        goal:
          type: string
        subtask_hints:
          type: array
        agent_pool:
          type: array

data_quality_pipeline:
  goal: Examine, detect, classify, measure, clean, verify, and audit data quality issues.
  risk: medium
  description: |
    Data quality pipeline inspired by OASF Category 9 (Data Engineering).
    Examines raw data, detects quality problems, classifies issue types,
    computes quality metrics, applies cleaning transformations, verifies
    cleaned data against quality thresholds, and records all transformations
    applied for reproducibility.
  success:
  - Raw data examined for quality issues
  - Issues detected and classified
  - Quality metrics computed
  - Cleaning transformations applied
  - Cleaned data verified against thresholds
  - All transformations recorded for audit
  steps:
  - capability: observe
    purpose: Examine raw data structure, schema, and sample values.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: observe_out
    input_bindings:
      target: ${raw_data.format}
    failure_modes:
    - condition: Unable to read or parse data
      action: stop
      recovery: Report format incompatibility and request data in supported format.
  - capability: detect
    purpose: Find quality problems such as nulls, outliers, duplicates, and format issues.
    domain: data_issue
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_out
    input_bindings:
      data: "${observe_out.observation: object}"
      pattern: data_quality_issue
    failure_modes: []
  - capability: classify
    purpose: Categorize detected issues by type and severity.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: classify_out
    input_bindings:
      item: "${detect_out.matches: array<object>}"
    failure_modes: []
  - capability: measure
    purpose: Compute quality metrics (completeness, consistency, accuracy, timeliness).
    domain: quality
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: measure_out
    input_bindings:
      target: "${detect_out.matches: array<object>}"
      metric: quality
    failure_modes: []
  - capability: checkpoint
    purpose: Save data state before applying cleaning transformations.
    risk: medium
    mutation: true
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: checkpoint_out
    failure_modes: []
  - capability: transform
    purpose: Apply cleaning operations to fix detected quality issues.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: transform_out
    input_bindings:
      input: "${classify_out.labels: array<object>}"
      target_format: cleaned
    failure_modes:
    - condition: Transformation produces unexpected results
      action: pause_and_checkpoint
      recovery: Review transformation rules and retry with adjusted parameters.
  - capability: verify
    purpose: Validate cleaned data meets quality thresholds.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry:
      max: 2
      backoff: exponential
    store_as: verify_out
    failure_modes:
    - condition: Cleaned data fails quality threshold
      action: rollback
      recovery: Rollback to checkpoint, adjust cleaning rules, and retry.
  - capability: audit
    purpose: Record all transformations applied and quality metrics before/after.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: data_quality_pipeline
        detected: ${detect_out.detected}
        quality_score: ${measure_out.value}
        transformations: "${transform_out.output: object}"
        verification: ${verify_out.passed}
    failure_modes: []
  - capability: rollback
    purpose: If verification fails, revert data to pre-cleaning checkpoint.
    risk: medium
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: null
    retry: null
    store_as: rollback_out
    gates:
    - when: ${verify_out.passed} == true
      action: skip
      message: Cleaned data passed verification. No rollback needed.
    failure_modes: []
  risk_propagation:
    strategy: max_step_risk
    computed_risk: medium
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    raw_data:
      type: object
      required: true
      description: The raw data to be quality-checked and cleaned
      properties:
        format:
          type: string
        schema:
          type: object
        quality_thresholds:
          type: object

model_deployment:
  goal: Safely deploy an ML model to production with validation, policy checks, and rollback capability.
  risk: high
  description: |
    Model deployment workflow inspired by OASF Category 12 (DevOps/MLOps).
    Validates model artifacts, checks deployment policies, creates a rollback
    checkpoint, executes deployment scripts, verifies deployment success,
    measures model performance post-deployment, and records the deployment
    event. Includes automatic rollback on verification failure.
  success:
  - Model artifacts validated
  - Deployment policies satisfied
  - Rollback checkpoint created
  - Deployment executed successfully
  - Post-deployment verification passed
  - Performance metrics within thresholds
  - Deployment event recorded
  steps:
  - capability: verify
    purpose: Validate model artifacts (weights, config, schema compatibility).
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry: null
    store_as: verify_artifacts_out
    input_bindings:
      target: ${model_package}
      conditions:
      - artifact_integrity
      - schema_compatibility
      - version_consistency
    failure_modes:
    - condition: Model artifacts invalid or corrupted
      action: stop
      recovery: Report validation failures and request corrected artifacts.
  - capability: constrain
    purpose: Check deployment policies (approval gates, resource limits, compliance).
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: constrain_out
    input_bindings:
      target: ${deployment_config}
      constraints:
      - deployment_policy
      - resource_limits
      - compliance_requirements
    failure_modes:
    - condition: Policy violation detected
      action: stop
      recovery: Report policy violations and required remediation steps.
  - capability: checkpoint
    purpose: Save rollback point before deployment begins.
    risk: medium
    mutation: true
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: checkpoint_out
    failure_modes: []
  - capability: execute
    purpose: Run deployment scripts to push model to production.
    risk: high
    mutation: true
    requires_checkpoint: true
    requires_approval: true
    timeout: 5m
    retry: null
    store_as: execute_out
    input_bindings:
      code: ${deployment_config.deploy_command}
    gates:
    - when: ${constrain_out.compliant} == false
      action: stop
      message: Deployment blocked by policy violation.
    - when: ${checkpoint_out.checkpoint_id} == null
      action: stop
      message: No checkpoint created. Do not deploy.
    failure_modes:
    - condition: Deployment script fails
      action: rollback
      recovery: Rollback to checkpoint and report deployment failure.
  - capability: verify
    purpose: Validate deployment success (health checks, endpoint availability).
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry:
      max: 3
      backoff: exponential
    store_as: verify_deploy_out
    failure_modes:
    - condition: Deployment health check fails
      action: rollback
      recovery: Rollback to checkpoint and investigate deployment issues.
  - capability: measure
    purpose: Check model performance metrics post-deployment.
    domain: performance
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: measure_out
    input_bindings:
      target: "${verify_deploy_out.results: array<object>}"
      metric: performance
    gates:
    - when: ${verify_deploy_out.passed} == false
      action: skip
      message: Deployment verification failed. Skipping performance check.
    failure_modes: []
  - capability: audit
    purpose: Record deployment event with full provenance.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: model_deployment
        model: ${model_package.model_id}
        version: ${model_package.version}
        deployment_result: "${execute_out.result: object}"
        verification: ${verify_deploy_out.passed}
        performance: ${measure_out.value}
    failure_modes: []
  - capability: rollback
    purpose: If verification fails, revert deployment to checkpoint.
    risk: medium
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: null
    retry: null
    store_as: rollback_out
    gates:
    - when: ${verify_deploy_out.passed} == true
      action: skip
      message: Deployment verified successfully. No rollback needed.
    failure_modes: []
  risk_propagation:
    strategy: max_step_risk
    computed_risk: high
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    model_package:
      type: object
      required: true
      description: The ML model package to deploy
      properties:
        model_id:
          type: string
        version:
          type: string
        artifacts:
          type: object
    deployment_config:
      type: object
      required: true
      description: Deployment configuration including target environment and policies
      properties:
        environment:
          type: string
        deploy_command:
          type: string
        policies:
          type: object
