# Workflow Catalog (36-capability model)
# Maps to capability_ontology.json
#
# Domain-specific workflows are in separate files:
#   - schemas/workflows/manufacturing_workflows.yaml
#   - schemas/workflows/personal_assistant_workflows.yaml
#   - schemas/workflows/data_analysis_workflows.yaml
#   - schemas/workflows/healthcare_workflows.yaml
#
# See docs/domains/ for domain documentation and customization guides.
#
# Capability Mapping (old → new):
#   inspect → observe
#   map-relationships → attribute
#   model-schema → constrain
#   act-plan → execute
#   identity-resolution → (composition: detect + classify + integrate)
#   world-state → state
#   state-transition → transition
#   causal-model → attribute
#   uncertainty-model → measure (with domain: uncertainty)
#   provenance → audit
#   grounding → ground
#   simulation → simulate
#   summarize → explain
#   discover-relationship → discover
#   compare-plans → compare
#   prioritize → compare (with domain: priority)
#   generate-plan → generate (with domain: plan)
#   diff-world-state → compare (with domain: state_diff)
#   detect-anomaly → detect (with domain: anomaly)
#   estimate-risk → measure (with domain: risk)
#   forecast-risk → predict (with domain: risk)
#   invoke-workflow → invoke
#
# New workflow patterns (Issue #9):
#   monitor-and-replan: Detect world changes and trigger replanning when needed
#   clarify-intent: Resolve ambiguous user requests through clarification

monitor_and_replan:
  goal: Detect world changes that invalidate the current plan and trigger replanning when needed.
  risk: medium
  description: |
    This workflow pattern continuously monitors world state against plan assumptions
    and triggers replanning when significant divergence is detected. It's designed
    to be invoked periodically during plan execution or when external events suggest
    the world may have changed.
  success:
  - Plan assumptions validated OR violations detected
  - If violations detected, revised plan generated
  - Audit trail of assumption checks maintained
  steps:
  - capability: observe
    purpose: Capture current world state for comparison.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: current_state_out
    failure_modes:
    - condition: Unable to observe relevant state
      action: request_more_context
      recovery: Request specific state aspects to monitor.
  - capability: state
    purpose: Create structured state representation.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: world_state_out
    input_bindings:
      scope: ${plan.scope}
    failure_modes: []
  - capability: compare
    purpose: Compare current state against plan assumptions.
    domain: assumption_validation
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: comparison_out
    input_bindings:
      options:
      - ${world_state_out}
      - ${plan.assumed_state}
      criteria:
      - assumption_validity
      - state_divergence
    failure_modes: []
  - capability: detect
    purpose: Detect assumption violations that affect plan validity.
    domain: plan-invalidation
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: violations_out
    input_bindings:
      data: ${comparison_out}
      pattern: assumption_violation
    gates:
    - when: ${comparison_out.confidence} > 0.9
      action: stop
      message: No significant divergence detected, plan remains valid.
    failure_modes: []
  - capability: critique
    purpose: Assess impact of violations on current plan.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: critique_out
    input_bindings:
      target: ${plan}
      criteria:
      - step_validity
      - goal_achievability
      - resource_availability
    failure_modes: []
  - capability: plan
    purpose: Generate revised plan incorporating new constraints.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: revised_plan_out
    input_bindings:
      goal: ${plan.goal}
      constraints:
      - ${violations_out.matches: array<object>}
      - ${critique_out.suggestions: array<string>}
    gates:
    - when: ${critique_out.severity} == "minor"
      action: skip
      message: Minor violation, continue with current plan.
    failure_modes:
    - condition: Unable to find viable plan
      action: stop
      recovery: Escalate to human with violation details.
  - capability: audit
    purpose: Record assumption check and any replanning decision.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: assumption_check
        original_plan: ${plan.id}
        violations: ${violations_out.detected}
        revised_plan: "${revised_plan_out.steps: array<object>}"
    failure_modes: []
  inputs:
    plan:
      type: object
      required: true
      properties:
        id: {type: string}
        goal: {type: string}
        scope: {type: string}
        assumed_state: {type: object}

clarify_intent:
  goal: Resolve ambiguous user requests through targeted clarification questions.
  risk: low
  description: |
    This workflow analyzes a user request for ambiguity, generates clarifying
    questions when needed, and integrates the clarification to produce a
    well-specified request. It's designed to be invoked at the start of
    any workflow when the initial request may be underspecified.
  success:
  - Request analyzed for ambiguity
  - Clarifying questions generated if needed
  - Clarification integrated into resolved request
  steps:
  - capability: critique
    purpose: Analyze request for ambiguity and missing parameters.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: ambiguity_analysis_out
    input_bindings:
      target: ${user_request}
      criteria:
      - parameter_completeness
      - interpretation_uniqueness
      - constraint_clarity
    failure_modes: []
  - capability: inquire
    purpose: Generate clarifying questions for ambiguous elements.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: clarification_request_out
    input_bindings:
      ambiguous_input: ${user_request}
      context: ${conversation_context}
      max_questions: 3
    gates:
    - when: ${ambiguity_analysis_out.confidence} > 0.85
      action: skip
      message: Request is sufficiently clear, no clarification needed.
    failure_modes: []
  - capability: send
    purpose: Present clarifying questions to user.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: sent_questions_out
    input_bindings:
      destination: user
      payload: ${clarification_request_out.questions}
    gates:
    - when: ${clarification_request_out.confidence} < 0.5
      action: skip
      message: No clarifying questions needed.
    failure_modes: []
  - capability: receive
    purpose: Accept user's clarification response.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry: null
    store_as: clarification_response_out
    input_bindings:
      channel: user
      filter:
        type: clarification_response
    gates:
    - when: ${sent_questions_out} == null
      action: skip
      message: No questions were sent, nothing to receive.
    failure_modes:
    - condition: Timeout waiting for response
      action: stop
      recovery: Proceed with best interpretation or escalate.
  - capability: integrate
    purpose: Merge clarification with original request.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: resolved_request_out
    input_bindings:
      sources:
      - ${user_request}
      - ${clarification_response_out.data}
      strategy: parameter_merge
      conflict_resolution: prefer_clarification
    failure_modes: []
  - capability: audit
    purpose: Record clarification interaction for provenance.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    input_bindings:
      event:
        type: intent_clarification
        original_request: ${user_request}
        questions_asked: ${clarification_request_out.questions}
        clarification_received: ${clarification_response_out.data}
        resolved_request: ${resolved_request_out}
    failure_modes: []
  inputs:
    user_request:
      type: string
      required: true
      description: The potentially ambiguous user request
    conversation_context:
      type: object
      required: false
      description: Previous conversation context for better question generation

debug_code_change:
  goal: Safely diagnose and fix a bug/regression in a codebase.
  risk: medium
  steps:
  - capability: observe
    purpose: Observe failing behavior, logs, and relevant code paths.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: observe_out
    failure_modes:
    - condition: No relevant signals found
      action: request_more_context
      recovery: Ask for reproduction steps or additional artifacts.
  - capability: search
    purpose: Find related code, configs, and error patterns.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: search_out
    failure_modes: []
  - capability: attribute
    purpose: Build dependency graph and identify causal relationships around failing component.
    domain: dependencies
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: attribute_out
    failure_modes: []
  - capability: constrain
    purpose: Define invariants/spec expectations for the component.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: constrain_out
    failure_modes: []
  - capability: critique
    purpose: List likely failure modes + edge cases.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: critique_out
    failure_modes: []
  - capability: plan
    purpose: Produce minimal fix plan with checkpoints.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: plan_out
    failure_modes: []
  - capability: checkpoint
    purpose: Create checkpoint before mutation.
    risk: medium
    mutation: true
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: checkpoint_out
    failure_modes: []
  - capability: execute
    purpose: Apply fix, run tests, and produce diff summary.
    risk: high
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: 5m
    retry: null
    store_as: execute_out
    failure_modes:
    - condition: Unexpected side effects
      action: pause_and_checkpoint
      recovery: Checkpoint and require human approval.
  - capability: verify
    purpose: Run targeted verification and return PASS/FAIL.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry:
      max: 3
      backoff: exponential
    store_as: verify_out
    failure_modes:
    - condition: Verdict == FAIL
      action: rollback
      recovery: Rollback, then return to critique/plan with new evidence.
  - capability: audit
    purpose: Record what changed and why.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
  - capability: rollback
    purpose: If verify FAIL, revert safely.
    risk: medium
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: null
    retry: null
    store_as: rollback_out
    failure_modes: []
  success:
  - Bug fixed or root cause isolated
  - Verification PASS
  - Audit trail produced
  risk_propagation:
    strategy: max_step_risk
    computed_risk: high
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

world_model_build:
  goal: Construct a structured world model for a domain (real or digital) with dynamics and uncertainty.
  risk: low
  steps:
  - capability: retrieve
    purpose: Collect authoritative domain sources and constraints.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: retrieve_out
    failure_modes: []
  - capability: observe
    purpose: Observe current system/world artifacts (docs, logs, sensors).
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: observe_out
    failure_modes:
    - condition: No relevant signals found
      action: request_more_context
      recovery: Ask for reproduction steps or additional artifacts.
  - capability: detect
    purpose: Detect entities across sources.
    domain: entity
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_out
    failure_modes: []
  - capability: classify
    purpose: Classify detected entities and resolve types.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: classify_out
    failure_modes: []
  - capability: integrate
    purpose: Merge entity data and resolve identity across sources.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: integrate_out
    failure_modes: []
  - capability: state
    purpose: Define state variables and current estimates.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: state_out
    failure_modes: []
  - capability: transition
    purpose: 'Define dynamics: transitions, triggers, guards.'
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: transition_out
    failure_modes: []
  - capability: attribute
    purpose: Define causal assumptions and intervention effects.
    domain: causation
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: attribute_out
    failure_modes: []
  - capability: measure
    purpose: Attach uncertainty types and confidence.
    domain: uncertainty
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: measure_out
    failure_modes: []
  - capability: audit
    purpose: Establish lineage for claims and transformations.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
  - capability: ground
    purpose: Anchor each model element to evidence references.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: ground_out
    failure_modes: []
  - capability: simulate
    purpose: Run scenarios to stress-test model and identify fragility.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: simulate_out
    failure_modes: []
  - capability: explain
    purpose: Produce a decision-ready world model brief.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: explain_out
    failure_modes: []
  success:
  - Model is structured (YAML/JSON)
  - Every claim is grounded
  - Uncertainty explicitly represented
  - Scenario results provided
  risk_propagation:
    strategy: max_step_risk
    computed_risk: low
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

capability_gap_analysis:
  goal: Assess a project/system to identify missing capabilities and propose new skills.
  risk: low
  steps:
  - capability: observe
    purpose: Read project docs and current skill coverage.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: observe_out
    failure_modes:
    - condition: No relevant signals found
      action: request_more_context
      recovery: Ask for reproduction steps or additional artifacts.
  - capability: attribute
    purpose: Map existing workflows vs capabilities.
    domain: dependencies
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: attribute_out
    failure_modes: []
  - capability: discover
    purpose: Find hidden dependencies or unmodeled interactions.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: discover_out
    failure_modes: []
  - capability: compare
    purpose: Compare alternative skill architectures.
    domain: architecture
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: compare_architecture_out
    failure_modes: []
  - capability: compare
    purpose: Rank missing capabilities by leverage and risk reduction.
    domain: priority
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: compare_priority_out
    failure_modes: []
  - capability: generate
    purpose: Generate an implementation plan for new skills.
    domain: plan
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: generate_out
    failure_modes: []
  - capability: audit
    purpose: Record rationale + decision lineage.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
  success:
  - Missing capability list
  - Prioritized backlog
  - Proposed skill specs
  risk_propagation:
    strategy: max_step_risk
    computed_risk: medium
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output is stored under store_as and may be referenced by later steps.
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

digital_twin_sync_loop:
  goal: Synchronize digital twin state with incoming signals, detect drift, decide and execute safe actions, and record provenance.
  risk: high
  success:
  - Twin snapshot updated and grounded
  - Drift assessed with risk score
  - Any actions are approved/checkpointed/verified
  - Audit trail produced
  data_flow:
    pattern: step_outputs_are_addressable
    rule: Each step output stored as `store_as`; later steps may reference it.
  steps:
  - capability: receive
    purpose: Ingest new signals/events from sources (logs/APIs/messages).
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry:
      max: 3
      backoff: exponential
    store_as: receive_out
    failure_modes:
    - condition: No messages/events available
      action: stop
      recovery: Wait for signals or confirm source configuration.
    input_bindings: {}
    gates: []
  - capability: search
    purpose: 'Parallel enrichment: search for existing twin snapshot or relevant context while ingesting events.'
    parallel_group: context_gathering
    join: all_complete
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: search_out
    input_bindings:
      target: ${receive_out.source}
    failure_modes: []
  - capability: transform
    purpose: Normalize raw signals into canonical events compatible with state.observations.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: transform_out
    failure_modes: []
    input_bindings:
      source: '${receive_out.data}'
      target_schema: canonical_event
    gates: []
    mapping_ref: schemas/transforms/transform_mapping_rawlog_to_observation.yaml
    output_conforms_to: schemas/event_schema.yaml#/event
  - capability: integrate
    purpose: Merge canonical events with existing twin snapshot; resolve conflicts via strategy.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: integrate_out
    failure_modes:
    - condition: Conflicts exceed threshold
      action: request_more_context
      recovery: Ask for resolution strategy or authoritative source preference.
    input_bindings:
      sources:
      - '${transform_out.output}'
      - '${previous_world_state}'
      resolution_strategy: prefer_authoritative_sources
    gates: []
    resolution_strategy: prefer_authoritative_sources
    conflict_resolution_strategies:
    - prefer_authoritative_sources
    - prefer_recent
    - prefer_high_confidence
    - merge_with_uncertainty
    - escalate_to_human
  - capability: detect
    purpose: Detect entities in integrated data.
    domain: entity
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_entity_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: classify
    purpose: Classify and resolve entity identities.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: classify_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: state
    purpose: Produce updated canonical world-state snapshot with uncertainty + provenance.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: state_out
    failure_modes: []
    input_bindings:
      observations: '${integrate_out.merged.observations: array<object>}'
      domain: ${integrate_out.merged.meta.world_id}
    gates: []
    output_conforms_to: schemas/world_state_schema.yaml#/world_state
  - capability: compare
    purpose: Compute diff between previous snapshot and updated snapshot.
    domain: state_diff
    store_as: compare_state_out
    input_bindings:
      state_a: '${previous_world_state: object}'
      state_b: '${state_out: object}'
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    failure_modes: []
  - capability: transition
    purpose: Apply transition rules triggered by new observations; compute next states.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: transition_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: detect
    purpose: Detect drift/anomalies between expected and observed state.
    domain: anomaly
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: detect_anomaly_out
    failure_modes: []
    input_bindings:
      context: ${state_out}
    gates: []
  - capability: measure
    purpose: Estimate risk impact/probability from drift and transitions.
    domain: risk
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: measure_risk_out
    failure_modes: []
    input_bindings:
      context: ${detect_anomaly_out}
    gates: []
  - capability: predict
    purpose: Forecast near-term risk trajectory and triggers.
    domain: risk
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: predict_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: plan
    purpose: Plan safe action(s) to reduce risk, with verification criteria and rollback plan.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: plan_out
    failure_modes: []
    input_bindings:
      context: ${predict_out}
    gates: []
  - capability: constrain
    purpose: Enforce policy and least privilege for planned actions.
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: constrain_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: checkpoint
    purpose: Create checkpoint marker before any mutation/side-effect step.
    risk: medium
    mutation: true
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: checkpoint_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: mutate
    purpose: Execute mutations from action plan (if approved).
    risk: high
    mutation: true
    requires_checkpoint: true
    requires_approval: true
    timeout: 5m
    retry: null
    store_as: mutate_out
    failure_modes:
    - condition: Unexpected side effects
      action: pause_and_checkpoint
      recovery: Require human approval to proceed.
    input_bindings: {}
    gates:
    - when: ${checkpoint_out.checkpoint_id} == null
      action: stop
      message: No checkpoint created. Do not mutate.
    condition: ${constrain_out.compliant} == true
    skip_if_false: true
  - capability: execute
    purpose: Run verification tests and commands.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry: null
    store_as: execute_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: verify
    purpose: 'Verify outcome: PASS/FAIL with evidence.'
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: 5m
    retry:
      max: 3
      backoff: exponential
    store_as: verify_out
    failure_modes:
    - condition: Verdict == FAIL
      action: rollback
      recovery:
        goto_step: plan
        inject_context:
          failure_evidence: ${verify_out.failures}
        max_loops: 3
    input_bindings: {}
    gates:
    - when: ${verify_out.passed} == false
      action: rollback
      message: Verification failed. Rolling back.
  - capability: audit
    purpose: Record provenance, tool usage, diffs, and decision rationale.
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: audit_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: rollback
    purpose: If verify FAIL or side effects detected, rollback to checkpoint.
    risk: medium
    mutation: true
    requires_checkpoint: true
    requires_approval: false
    timeout: null
    retry: null
    store_as: rollback_out
    failure_modes: []
    input_bindings: {}
    gates: []
  - capability: explain
    purpose: 'Produce decision-ready sync report: drift, actions, verification, next steps.'
    risk: low
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    store_as: explain_out
    failure_modes: []
    input_bindings: {}
    gates: []
  workflow_extensions:
    supports_input_bindings: true
    supports_conditions: true
    supports_parallel_groups: true
    supports_recovery_loops: true
    supports_gates: true
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state

digital_twin_bootstrap:
  goal: Initialize a digital twin from scratch then run a first sync loop.
  risk: high
  success:
  - World model built
  - First sync completed
  - Audit produced
  steps:
  - capability: invoke
    purpose: Build initial world model baseline
    workflow_id: world_model_build
    store_as: world_model_out
    condition: ${world_state_out} == null
    skip_if_false: true
    input_bindings:
      inputs:
        domain: ${user_input.domain}
        constraints: ${user_input.constraints}
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    failure_modes: []
  - capability: invoke
    purpose: Run initial sync loop using baseline
    workflow_id: digital_twin_sync_loop
    store_as: sync_out
    input_bindings:
      inputs:
        # Note: result contains nested workflow output where state_out was stored
        world_state: ${world_model_out.result}
    risk: medium
    mutation: false
    requires_checkpoint: false
    requires_approval: false
    timeout: null
    retry: null
    failure_modes: []
  inputs:
    user_input:
      type: object
      properties:
        domain:
          type: string
        constraints:
          type: object
    previous_world_state:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
    world_state_out:
      type: object
      ref: schemas/world_state_schema.yaml#/world_state
